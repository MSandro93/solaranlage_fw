
solaranlage_fw.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000584  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         0000000c  00800060  00000584  00000618  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000013  0080006c  0080006c  00000624  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00000624  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  00000654  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 000001a8  00000000  00000000  00000690  2**3
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00001119  00000000  00000000  00000838  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 000009d6  00000000  00000000  00001951  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00001513  00000000  00000000  00002327  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000354  00000000  00000000  0000383c  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00006673  00000000  00000000  00003b90  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    000004ce  00000000  00000000  0000a203  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000108  00000000  00000000  0000a6d1  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_macro  00002819  00000000  00000000  0000a7d9  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
   4:	0c 94 fe 00 	jmp	0x1fc	; 0x1fc <__vector_1>
   8:	0c 94 34 01 	jmp	0x268	; 0x268 <__vector_2>
   c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  14:	0c 94 0c 02 	jmp	0x418	; 0x418 <__vector_5>
  18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  1c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  24:	0c 94 3d 02 	jmp	0x47a	; 0x47a <__vector_9>
  28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  2c:	0c 94 a8 00 	jmp	0x150	; 0x150 <__vector_11>
  30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
  54:	11 24       	eor	r1, r1
  56:	1f be       	out	0x3f, r1	; 63
  58:	cf e5       	ldi	r28, 0x5F	; 95
  5a:	d8 e0       	ldi	r29, 0x08	; 8
  5c:	de bf       	out	0x3e, r29	; 62
  5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
  60:	10 e0       	ldi	r17, 0x00	; 0
  62:	a0 e6       	ldi	r26, 0x60	; 96
  64:	b0 e0       	ldi	r27, 0x00	; 0
  66:	e4 e8       	ldi	r30, 0x84	; 132
  68:	f5 e0       	ldi	r31, 0x05	; 5
  6a:	02 c0       	rjmp	.+4      	; 0x70 <__do_copy_data+0x10>
  6c:	05 90       	lpm	r0, Z+
  6e:	0d 92       	st	X+, r0
  70:	ac 36       	cpi	r26, 0x6C	; 108
  72:	b1 07       	cpc	r27, r17
  74:	d9 f7       	brne	.-10     	; 0x6c <__do_copy_data+0xc>

00000076 <__do_clear_bss>:
  76:	20 e0       	ldi	r18, 0x00	; 0
  78:	ac e6       	ldi	r26, 0x6C	; 108
  7a:	b0 e0       	ldi	r27, 0x00	; 0
  7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
  7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
  80:	af 37       	cpi	r26, 0x7F	; 127
  82:	b2 07       	cpc	r27, r18
  84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
  86:	0e 94 88 01 	call	0x310	; 0x310 <main>
  8a:	0c 94 c0 02 	jmp	0x580	; 0x580 <_exit>

0000008e <__bad_interrupt>:
  8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <SevenSeg_init>:
uint8_t on = 0;


void SevenSeg_init()
{
	TIMSK |= (1<<TOIE0);	//enable overflow-interrupt
  92:	89 b7       	in	r24, 0x39	; 57
  94:	81 60       	ori	r24, 0x01	; 1
  96:	89 bf       	out	0x39, r24	; 57
	
	sei();
  98:	78 94       	sei
  9a:	08 95       	ret

0000009c <SevenSeg_set_val>:
}

//seg: 1=dach; 0=kessel;   val: 0-9: 0-9; 10: off
void SevenSeg_set_val(uint8_t seg, uint16_t val)
{
  9c:	0f 93       	push	r16
  9e:	1f 93       	push	r17
  a0:	cf 93       	push	r28
  a2:	df 93       	push	r29
  a4:	48 2f       	mov	r20, r24
  a6:	8b 01       	movw	r16, r22
	uint8_t h = (uint8_t) (val/100);
  a8:	cb 01       	movw	r24, r22
  aa:	64 e6       	ldi	r22, 0x64	; 100
  ac:	70 e0       	ldi	r23, 0x00	; 0
  ae:	0e 94 93 02 	call	0x526	; 0x526 <__udivmodhi4>
  b2:	9b 01       	movw	r18, r22
	uint8_t z = (uint8_t) ((val- (h*100)) / 10 );
  b4:	eb 01       	movw	r28, r22
  b6:	dd 27       	eor	r29, r29
  b8:	c8 01       	movw	r24, r16
  ba:	54 e6       	ldi	r21, 0x64	; 100
  bc:	65 9f       	mul	r22, r21
  be:	80 19       	sub	r24, r0
  c0:	91 09       	sbc	r25, r1
  c2:	11 24       	eor	r1, r1
  c4:	ea e0       	ldi	r30, 0x0A	; 10
  c6:	f0 e0       	ldi	r31, 0x00	; 0
  c8:	bf 01       	movw	r22, r30
  ca:	0e 94 93 02 	call	0x526	; 0x526 <__udivmodhi4>
	uint8_t e = (uint8_t)  (val- (h*100)- (z*10));
  ce:	90 2f       	mov	r25, r16
  d0:	84 e6       	ldi	r24, 0x64	; 100
  d2:	28 9f       	mul	r18, r24
  d4:	90 19       	sub	r25, r0
  d6:	11 24       	eor	r1, r1
  d8:	29 2f       	mov	r18, r25
  da:	3a e0       	ldi	r19, 0x0A	; 10
  dc:	63 9f       	mul	r22, r19
  de:	20 19       	sub	r18, r0
  e0:	11 24       	eor	r1, r1
  e2:	84 2f       	mov	r24, r20
  e4:	90 e0       	ldi	r25, 0x00	; 0
	
	if(val==1000)
  e6:	08 3e       	cpi	r16, 0xE8	; 232
  e8:	13 40       	sbci	r17, 0x03	; 3
  ea:	b1 f4       	brne	.+44     	; 0x118 <SevenSeg_set_val+0x7c>
	{
		segs[seg]   = 10;
  ec:	dc 01       	movw	r26, r24
  ee:	aa 0f       	add	r26, r26
  f0:	bb 1f       	adc	r27, r27
  f2:	a2 59       	subi	r26, 0x92	; 146
  f4:	bf 4f       	sbci	r27, 0xFF	; 255
  f6:	ed 93       	st	X+, r30
  f8:	fc 93       	st	X, r31
		segs[seg+2] = 10;
  fa:	dc 01       	movw	r26, r24
  fc:	aa 0f       	add	r26, r26
  fe:	bb 1f       	adc	r27, r27
 100:	ae 58       	subi	r26, 0x8E	; 142
 102:	bf 4f       	sbci	r27, 0xFF	; 255
 104:	ed 93       	st	X+, r30
 106:	fc 93       	st	X, r31
		segs[seg+4] = 10;
 108:	88 0f       	add	r24, r24
 10a:	99 1f       	adc	r25, r25
 10c:	dc 01       	movw	r26, r24
 10e:	aa 58       	subi	r26, 0x8A	; 138
 110:	bf 4f       	sbci	r27, 0xFF	; 255
 112:	ed 93       	st	X+, r30
 114:	fc 93       	st	X, r31
		return;
 116:	17 c0       	rjmp	.+46     	; 0x146 <SevenSeg_set_val+0xaa>
	}
	
	segs[seg]   = e;
 118:	fc 01       	movw	r30, r24
 11a:	ee 0f       	add	r30, r30
 11c:	ff 1f       	adc	r31, r31
 11e:	e2 59       	subi	r30, 0x92	; 146
 120:	ff 4f       	sbci	r31, 0xFF	; 255
 122:	30 e0       	ldi	r19, 0x00	; 0
 124:	31 83       	std	Z+1, r19	; 0x01
 126:	20 83       	st	Z, r18
	segs[seg+2] = z;
 128:	fc 01       	movw	r30, r24
 12a:	ee 0f       	add	r30, r30
 12c:	ff 1f       	adc	r31, r31
 12e:	ee 58       	subi	r30, 0x8E	; 142
 130:	ff 4f       	sbci	r31, 0xFF	; 255
 132:	77 27       	eor	r23, r23
 134:	71 83       	std	Z+1, r23	; 0x01
 136:	60 83       	st	Z, r22
	segs[seg+4] = h;
 138:	88 0f       	add	r24, r24
 13a:	99 1f       	adc	r25, r25
 13c:	fc 01       	movw	r30, r24
 13e:	ea 58       	subi	r30, 0x8A	; 138
 140:	ff 4f       	sbci	r31, 0xFF	; 255
 142:	d1 83       	std	Z+1, r29	; 0x01
 144:	c0 83       	st	Z, r28
}
 146:	df 91       	pop	r29
 148:	cf 91       	pop	r28
 14a:	1f 91       	pop	r17
 14c:	0f 91       	pop	r16
 14e:	08 95       	ret

00000150 <__vector_11>:


ISR(TIMER0_OVF_vect)
{
 150:	1f 92       	push	r1
 152:	0f 92       	push	r0
 154:	0f b6       	in	r0, 0x3f	; 63
 156:	0f 92       	push	r0
 158:	11 24       	eor	r1, r1
 15a:	2f 93       	push	r18
 15c:	8f 93       	push	r24
 15e:	9f 93       	push	r25
 160:	ef 93       	push	r30
 162:	ff 93       	push	r31
	PORTD |= (1<<PD5);
 164:	95 9a       	sbi	0x12, 5	; 18
	cli();
 166:	f8 94       	cli

	
//	PORTD ^= (1<<PD5);
	
	PORTB = patterns[segs[seg_cnt]];
 168:	e0 91 6d 00 	lds	r30, 0x006D	; 0x80006d <seg_cnt>
 16c:	f0 e0       	ldi	r31, 0x00	; 0
 16e:	ee 0f       	add	r30, r30
 170:	ff 1f       	adc	r31, r31
 172:	e2 59       	subi	r30, 0x92	; 146
 174:	ff 4f       	sbci	r31, 0xFF	; 255
 176:	01 90       	ld	r0, Z+
 178:	f0 81       	ld	r31, Z
 17a:	e0 2d       	mov	r30, r0
 17c:	e0 5a       	subi	r30, 0xA0	; 160
 17e:	ff 4f       	sbci	r31, 0xFF	; 255
 180:	80 81       	ld	r24, Z
 182:	88 bb       	out	0x18, r24	; 24
	
	uint8_t a = (uint8_t) (~(1<<(seg_cnt + 2)));
 184:	20 91 6d 00 	lds	r18, 0x006D	; 0x80006d <seg_cnt>
 188:	2e 5f       	subi	r18, 0xFE	; 254
 18a:	81 e0       	ldi	r24, 0x01	; 1
 18c:	90 e0       	ldi	r25, 0x00	; 0
 18e:	01 c0       	rjmp	.+2      	; 0x192 <__vector_11+0x42>
 190:	88 0f       	add	r24, r24
 192:	2a 95       	dec	r18
 194:	ea f7       	brpl	.-6      	; 0x190 <__vector_11+0x40>
 196:	80 95       	com	r24
	PORTA = a;
 198:	8b bb       	out	0x1b, r24	; 27
	seg_cnt ++;
 19a:	80 91 6d 00 	lds	r24, 0x006D	; 0x80006d <seg_cnt>
 19e:	8f 5f       	subi	r24, 0xFF	; 255
	
	if(seg_cnt == 6)
 1a0:	86 30       	cpi	r24, 0x06	; 6
 1a2:	19 f0       	breq	.+6      	; 0x1aa <__vector_11+0x5a>
	
	PORTB = patterns[segs[seg_cnt]];
	
	uint8_t a = (uint8_t) (~(1<<(seg_cnt + 2)));
	PORTA = a;
	seg_cnt ++;
 1a4:	80 93 6d 00 	sts	0x006D, r24	; 0x80006d <seg_cnt>
 1a8:	02 c0       	rjmp	.+4      	; 0x1ae <__vector_11+0x5e>
	
	if(seg_cnt == 6)
	{
		seg_cnt = 0;
 1aa:	10 92 6d 00 	sts	0x006D, r1	; 0x80006d <seg_cnt>
	}
	
	TIFR &= ~(1<<TOV0);
 1ae:	88 b7       	in	r24, 0x38	; 56
 1b0:	8e 7f       	andi	r24, 0xFE	; 254
 1b2:	88 bf       	out	0x38, r24	; 56
	
	sei();
 1b4:	78 94       	sei
	PORTD &= ~(1<<PD5);
 1b6:	95 98       	cbi	0x12, 5	; 18
}
 1b8:	ff 91       	pop	r31
 1ba:	ef 91       	pop	r30
 1bc:	9f 91       	pop	r25
 1be:	8f 91       	pop	r24
 1c0:	2f 91       	pop	r18
 1c2:	0f 90       	pop	r0
 1c4:	0f be       	out	0x3f, r0	; 63
 1c6:	0f 90       	pop	r0
 1c8:	1f 90       	pop	r1
 1ca:	18 95       	reti

000001cc <SevenSeg_on>:


void SevenSeg_on()
{
	TCCR0 = (1<<CS01) | (1<<CS00);		//setting prescaler to /256
 1cc:	83 e0       	ldi	r24, 0x03	; 3
 1ce:	83 bf       	out	0x33, r24	; 51
	on = 1;
 1d0:	81 e0       	ldi	r24, 0x01	; 1
 1d2:	80 93 6c 00 	sts	0x006C, r24	; 0x80006c <__data_end>
 1d6:	08 95       	ret

000001d8 <SevenSeg_off>:
}

void SevenSeg_off()
{
	TCCR0 &= ~((1<<CS01) | (1<<CS00));		//setting prescaler to /256
 1d8:	83 b7       	in	r24, 0x33	; 51
 1da:	8c 7f       	andi	r24, 0xFC	; 252
 1dc:	83 bf       	out	0x33, r24	; 51
	PORTB = 0x00;
 1de:	18 ba       	out	0x18, r1	; 24
	PORTA = 0xFF;
 1e0:	8f ef       	ldi	r24, 0xFF	; 255
 1e2:	8b bb       	out	0x1b, r24	; 27
	on = 0;
 1e4:	10 92 6c 00 	sts	0x006C, r1	; 0x80006c <__data_end>
 1e8:	08 95       	ret

000001ea <Encoder_init>:
uint8_t selected_seg = 1;


void Encoder_init()
{
	ENC_PORT &= ~((1<<ENC_A_PIN) | (1<<ENC_A_PIN));							//setting encoder terminals to input
 1ea:	92 98       	cbi	0x12, 2	; 18
	MCUCR |= (1<<ISC01) | (1<<ISC00) | (1<<ISC11);				//setting ext-int0 to sensitive at rising edge
 1ec:	85 b7       	in	r24, 0x35	; 53
 1ee:	8b 60       	ori	r24, 0x0B	; 11
 1f0:	85 bf       	out	0x35, r24	; 53
	GICR |= (1<<INT0) | (1<<INT1);											//enable external interrupt 0 (ENC_A_PIN)
 1f2:	8b b7       	in	r24, 0x3b	; 59
 1f4:	80 6c       	ori	r24, 0xC0	; 192
 1f6:	8b bf       	out	0x3b, r24	; 59
	sei();
 1f8:	78 94       	sei
 1fa:	08 95       	ret

000001fc <__vector_1>:
}



ISR(INT0_vect)
{	
 1fc:	1f 92       	push	r1
 1fe:	0f 92       	push	r0
 200:	0f b6       	in	r0, 0x3f	; 63
 202:	0f 92       	push	r0
 204:	11 24       	eor	r1, r1
 206:	2f 93       	push	r18
 208:	3f 93       	push	r19
 20a:	4f 93       	push	r20
 20c:	5f 93       	push	r21
 20e:	6f 93       	push	r22
 210:	7f 93       	push	r23
 212:	8f 93       	push	r24
 214:	9f 93       	push	r25
 216:	af 93       	push	r26
 218:	bf 93       	push	r27
 21a:	ef 93       	push	r30
 21c:	ff 93       	push	r31
	cli();
 21e:	f8 94       	cli
	
	switch(getState())
 220:	0e 94 dc 01 	call	0x3b8	; 0x3b8 <getState>
 224:	83 30       	cpi	r24, 0x03	; 3
 226:	39 f4       	brne	.+14     	; 0x236 <__vector_1+0x3a>
	{
		case 3:	
		{	
			if( (ENC_PINPORT & (1<<ENC_B_PIN)) > 0) //if ENC_B_PIN == 1  //gegen den Uhrzeigersinn
 228:	84 9b       	sbis	0x10, 4	; 16
 22a:	03 c0       	rjmp	.+6      	; 0x232 <__vector_1+0x36>
			{
				dec_delta();
 22c:	0e 94 f7 01 	call	0x3ee	; 0x3ee <dec_delta>
 230:	02 c0       	rjmp	.+4      	; 0x236 <__vector_1+0x3a>
			}		
			else									//im Uhrzeigersinn
			{				
				inc_delta();
 232:	0e 94 ed 01 	call	0x3da	; 0x3da <inc_delta>
		}
		default:
			break;
	}
	
	stop_timeout_timer();
 236:	0e 94 3a 02 	call	0x474	; 0x474 <stop_timeout_timer>
	start_timeout_timer();
 23a:	0e 94 35 02 	call	0x46a	; 0x46a <start_timeout_timer>
	
	
	GIFR &= ~(1<<INTF0);  //clear ext-interrupt-0 flag
 23e:	8a b7       	in	r24, 0x3a	; 58
 240:	8f 7b       	andi	r24, 0xBF	; 191
 242:	8a bf       	out	0x3a, r24	; 58
	
	sei();
 244:	78 94       	sei
}
 246:	ff 91       	pop	r31
 248:	ef 91       	pop	r30
 24a:	bf 91       	pop	r27
 24c:	af 91       	pop	r26
 24e:	9f 91       	pop	r25
 250:	8f 91       	pop	r24
 252:	7f 91       	pop	r23
 254:	6f 91       	pop	r22
 256:	5f 91       	pop	r21
 258:	4f 91       	pop	r20
 25a:	3f 91       	pop	r19
 25c:	2f 91       	pop	r18
 25e:	0f 90       	pop	r0
 260:	0f be       	out	0x3f, r0	; 63
 262:	0f 90       	pop	r0
 264:	1f 90       	pop	r1
 266:	18 95       	reti

00000268 <__vector_2>:

ISR(INT1_vect)  //if the encoder got pushed
{
 268:	1f 92       	push	r1
 26a:	0f 92       	push	r0
 26c:	0f b6       	in	r0, 0x3f	; 63
 26e:	0f 92       	push	r0
 270:	11 24       	eor	r1, r1
 272:	2f 93       	push	r18
 274:	3f 93       	push	r19
 276:	4f 93       	push	r20
 278:	5f 93       	push	r21
 27a:	6f 93       	push	r22
 27c:	7f 93       	push	r23
 27e:	8f 93       	push	r24
 280:	9f 93       	push	r25
 282:	af 93       	push	r26
 284:	bf 93       	push	r27
 286:	cf 93       	push	r28
 288:	ef 93       	push	r30
 28a:	ff 93       	push	r31
	cli();
 28c:	f8 94       	cli
	
	switch(getState())
 28e:	0e 94 dc 01 	call	0x3b8	; 0x3b8 <getState>
 292:	82 30       	cpi	r24, 0x02	; 2
 294:	31 f0       	breq	.+12     	; 0x2a2 <__vector_2+0x3a>
 296:	83 30       	cpi	r24, 0x03	; 3
 298:	51 f0       	breq	.+20     	; 0x2ae <__vector_2+0x46>
 29a:	81 30       	cpi	r24, 0x01	; 1
 29c:	11 f5       	brne	.+68     	; 0x2e2 <__vector_2+0x7a>
	{
		case 1:
		{
			setState(2);
 29e:	82 e0       	ldi	r24, 0x02	; 2
 2a0:	01 c0       	rjmp	.+2      	; 0x2a4 <__vector_2+0x3c>
			start_timeout_timer();
			break;
		}
		case 2:
		{
			setState(3);
 2a2:	83 e0       	ldi	r24, 0x03	; 3
 2a4:	0e 94 84 01 	call	0x308	; 0x308 <setState>
			start_timeout_timer();
 2a8:	0e 94 35 02 	call	0x46a	; 0x46a <start_timeout_timer>
			break;
 2ac:	1a c0       	rjmp	.+52     	; 0x2e2 <__vector_2+0x7a>
		}
		case 3:
		{
			if((getState() == 3) && (eeprom_read_byte(0) != get_delta()))
 2ae:	0e 94 dc 01 	call	0x3b8	; 0x3b8 <getState>
 2b2:	83 30       	cpi	r24, 0x03	; 3
 2b4:	99 f4       	brne	.+38     	; 0x2dc <__vector_2+0x74>
 2b6:	80 e0       	ldi	r24, 0x00	; 0
 2b8:	90 e0       	ldi	r25, 0x00	; 0
 2ba:	0e 94 a7 02 	call	0x54e	; 0x54e <eeprom_read_byte>
 2be:	c8 2f       	mov	r28, r24
 2c0:	0e 94 01 02 	call	0x402	; 0x402 <get_delta>
 2c4:	c8 17       	cp	r28, r24
 2c6:	51 f0       	breq	.+20     	; 0x2dc <__vector_2+0x74>
			{
				eeprom_update_byte(0, get_delta());
 2c8:	0e 94 01 02 	call	0x402	; 0x402 <get_delta>
 2cc:	68 2f       	mov	r22, r24
 2ce:	80 e0       	ldi	r24, 0x00	; 0
 2d0:	90 e0       	ldi	r25, 0x00	; 0
 2d2:	0e 94 af 02 	call	0x55e	; 0x55e <eeprom_update_byte>
				uart_send_blocking('s');
 2d6:	83 e7       	ldi	r24, 0x73	; 115
 2d8:	0e 94 8e 02 	call	0x51c	; 0x51c <uart_send_blocking>
			}
			setState(2);
 2dc:	82 e0       	ldi	r24, 0x02	; 2
 2de:	0e 94 84 01 	call	0x308	; 0x308 <setState>
			break;
		}
	}
	
	sei();
 2e2:	78 94       	sei
 2e4:	ff 91       	pop	r31
 2e6:	ef 91       	pop	r30
 2e8:	cf 91       	pop	r28
 2ea:	bf 91       	pop	r27
 2ec:	af 91       	pop	r26
 2ee:	9f 91       	pop	r25
 2f0:	8f 91       	pop	r24
 2f2:	7f 91       	pop	r23
 2f4:	6f 91       	pop	r22
 2f6:	5f 91       	pop	r21
 2f8:	4f 91       	pop	r20
 2fa:	3f 91       	pop	r19
 2fc:	2f 91       	pop	r18
 2fe:	0f 90       	pop	r0
 300:	0f be       	out	0x3f, r0	; 63
 302:	0f 90       	pop	r0
 304:	1f 90       	pop	r1
 306:	18 95       	reti

00000308 <setState>:
    }
}

void setState(uint8_t s)
{
	state = s;
 308:	80 93 7a 00 	sts	0x007A, r24	; 0x80007a <state>
	uart_send_blocking(s);
 30c:	0c 94 8e 02 	jmp	0x51c	; 0x51c <uart_send_blocking>

00000310 <main>:
volatile uint8_t state = 0;


int main(void)
{
	PORTA = 0x00;
 310:	1b ba       	out	0x1b, r1	; 27
	PORTB = 0x00;
 312:	18 ba       	out	0x18, r1	; 24
	
	DDRA = 0xFF;
 314:	8f ef       	ldi	r24, 0xFF	; 255
 316:	8a bb       	out	0x1a, r24	; 26
	DDRB = 0xFF;
 318:	87 bb       	out	0x17, r24	; 23
	DDRC |= (1<<WDI_PIN);
 31a:	a6 9a       	sbi	0x14, 6	; 20
	DDRD |= (1<<PD5);
 31c:	8d 9a       	sbi	0x11, 5	; 17
	
	uart_init(0);
 31e:	60 e0       	ldi	r22, 0x00	; 0
 320:	70 e0       	ldi	r23, 0x00	; 0
 322:	cb 01       	movw	r24, r22
 324:	0e 94 82 02 	call	0x504	; 0x504 <uart_init>
	regulator_init();
 328:	0e 94 df 01 	call	0x3be	; 0x3be <regulator_init>
	
	SevenSeg_init();
 32c:	0e 94 49 00 	call	0x92	; 0x92 <SevenSeg_init>
	SevenSeg_set_val(1, 123);
 330:	6b e7       	ldi	r22, 0x7B	; 123
 332:	70 e0       	ldi	r23, 0x00	; 0
 334:	81 e0       	ldi	r24, 0x01	; 1
 336:	0e 94 4e 00 	call	0x9c	; 0x9c <SevenSeg_set_val>
	SevenSeg_set_val(0, 1000);
 33a:	68 ee       	ldi	r22, 0xE8	; 232
 33c:	73 e0       	ldi	r23, 0x03	; 3
 33e:	80 e0       	ldi	r24, 0x00	; 0
 340:	0e 94 4e 00 	call	0x9c	; 0x9c <SevenSeg_set_val>
	
	Timeout_init();
 344:	0e 94 2f 02 	call	0x45e	; 0x45e <Timeout_init>
	Encoder_init();
 348:	0e 94 f5 00 	call	0x1ea	; 0x1ea <Encoder_init>
				SevenSeg_set_val(0, 1000); //set Kessel-display off
				break;
			}
		}
		
		WDI_PORT ^= (1<<WDI_PIN);
 34c:	c0 e4       	ldi	r28, 0x40	; 64
	Encoder_init();
	
    /* Replace with your application code */
    while (1) 
    {
		switch(state)
 34e:	80 91 7a 00 	lds	r24, 0x007A	; 0x80007a <state>
 352:	81 30       	cpi	r24, 0x01	; 1
 354:	c1 f0       	breq	.+48     	; 0x386 <main+0x76>
 356:	88 f0       	brcs	.+34     	; 0x37a <main+0x6a>
 358:	82 30       	cpi	r24, 0x02	; 2
 35a:	c1 f0       	breq	.+48     	; 0x38c <main+0x7c>
 35c:	83 30       	cpi	r24, 0x03	; 3
 35e:	41 f5       	brne	.+80     	; 0x3b0 <main+0xa0>
				break;
			}
			
			case 3: 
			{
				SevenSeg_set_val(1, get_delta());
 360:	0e 94 01 02 	call	0x402	; 0x402 <get_delta>
 364:	68 2f       	mov	r22, r24
 366:	70 e0       	ldi	r23, 0x00	; 0
 368:	81 e0       	ldi	r24, 0x01	; 1
 36a:	0e 94 4e 00 	call	0x9c	; 0x9c <SevenSeg_set_val>
				SevenSeg_set_val(0, 1000); //set Kessel-display off
 36e:	68 ee       	ldi	r22, 0xE8	; 232
 370:	73 e0       	ldi	r23, 0x03	; 3
 372:	80 e0       	ldi	r24, 0x00	; 0
 374:	0e 94 4e 00 	call	0x9c	; 0x9c <SevenSeg_set_val>
				break;
 378:	1b c0       	rjmp	.+54     	; 0x3b0 <main+0xa0>
    {
		switch(state)
		{
			case 0:
			{
				SevenSeg_off();
 37a:	0e 94 ec 00 	call	0x1d8	; 0x1d8 <SevenSeg_off>
				setState(1);
 37e:	81 e0       	ldi	r24, 0x01	; 1
 380:	0e 94 84 01 	call	0x308	; 0x308 <setState>
				break;
 384:	15 c0       	rjmp	.+42     	; 0x3b0 <main+0xa0>
			}
			
			case 1:
			{
				SevenSeg_off();
 386:	0e 94 ec 00 	call	0x1d8	; 0x1d8 <SevenSeg_off>
				break;
 38a:	12 c0       	rjmp	.+36     	; 0x3b0 <main+0xa0>
			}
				
			case 2:
			{
				SevenSeg_set_val(1, get_temp(1));
 38c:	81 e0       	ldi	r24, 0x01	; 1
 38e:	0e 94 04 02 	call	0x408	; 0x408 <get_temp>
 392:	68 2f       	mov	r22, r24
 394:	70 e0       	ldi	r23, 0x00	; 0
 396:	81 e0       	ldi	r24, 0x01	; 1
 398:	0e 94 4e 00 	call	0x9c	; 0x9c <SevenSeg_set_val>
				SevenSeg_set_val(0, get_temp(0));
 39c:	80 e0       	ldi	r24, 0x00	; 0
 39e:	0e 94 04 02 	call	0x408	; 0x408 <get_temp>
 3a2:	68 2f       	mov	r22, r24
 3a4:	70 e0       	ldi	r23, 0x00	; 0
 3a6:	80 e0       	ldi	r24, 0x00	; 0
 3a8:	0e 94 4e 00 	call	0x9c	; 0x9c <SevenSeg_set_val>
				SevenSeg_on();
 3ac:	0e 94 e6 00 	call	0x1cc	; 0x1cc <SevenSeg_on>
				SevenSeg_set_val(0, 1000); //set Kessel-display off
				break;
			}
		}
		
		WDI_PORT ^= (1<<WDI_PIN);
 3b0:	85 b3       	in	r24, 0x15	; 21
 3b2:	8c 27       	eor	r24, r28
 3b4:	85 bb       	out	0x15, r24	; 21
    }
 3b6:	cb cf       	rjmp	.-106    	; 0x34e <main+0x3e>

000003b8 <getState>:
	uart_send_blocking(s);
}

uint8_t getState()
{
	return state;
 3b8:	80 91 7a 00 	lds	r24, 0x007A	; 0x80007a <state>
}
 3bc:	08 95       	ret

000003be <regulator_init>:
	show_temps = 1;
}

void disable_show_temps(void)
{
	show_temps = 0;
 3be:	80 e0       	ldi	r24, 0x00	; 0
 3c0:	90 e0       	ldi	r25, 0x00	; 0
 3c2:	0e 94 a7 02 	call	0x54e	; 0x54e <eeprom_read_byte>
 3c6:	80 93 7e 00 	sts	0x007E, r24	; 0x80007e <delta>
 3ca:	85 b5       	in	r24, 0x25	; 37
 3cc:	87 60       	ori	r24, 0x07	; 7
 3ce:	85 bd       	out	0x25, r24	; 37
 3d0:	89 b7       	in	r24, 0x39	; 57
 3d2:	80 64       	ori	r24, 0x40	; 64
 3d4:	89 bf       	out	0x39, r24	; 57
 3d6:	78 94       	sei
 3d8:	08 95       	ret

000003da <inc_delta>:
}

void inc_delta()
{
	if(delta<100)
 3da:	80 91 7e 00 	lds	r24, 0x007E	; 0x80007e <delta>
 3de:	84 36       	cpi	r24, 0x64	; 100
 3e0:	28 f4       	brcc	.+10     	; 0x3ec <inc_delta+0x12>
		delta++;
 3e2:	80 91 7e 00 	lds	r24, 0x007E	; 0x80007e <delta>
 3e6:	8f 5f       	subi	r24, 0xFF	; 255
 3e8:	80 93 7e 00 	sts	0x007E, r24	; 0x80007e <delta>
 3ec:	08 95       	ret

000003ee <dec_delta>:
}

void dec_delta()
{
	if(delta>0)
 3ee:	80 91 7e 00 	lds	r24, 0x007E	; 0x80007e <delta>
 3f2:	88 23       	and	r24, r24
 3f4:	29 f0       	breq	.+10     	; 0x400 <__LOCK_REGION_LENGTH__>
		delta --;
 3f6:	80 91 7e 00 	lds	r24, 0x007E	; 0x80007e <delta>
 3fa:	81 50       	subi	r24, 0x01	; 1
 3fc:	80 93 7e 00 	sts	0x007E, r24	; 0x80007e <delta>
 400:	08 95       	ret

00000402 <get_delta>:
}

uint8_t get_delta()
{
	return delta;
 402:	80 91 7e 00 	lds	r24, 0x007E	; 0x80007e <delta>
}
 406:	08 95       	ret

00000408 <get_temp>:


//sensor: 1=dach; 0=kessel
uint8_t get_temp(uint8_t sensor)
{
	if(sensor==0)
 408:	81 11       	cpse	r24, r1
 40a:	03 c0       	rjmp	.+6      	; 0x412 <get_temp+0xa>
		return temp_kessel;	//dummy
 40c:	80 91 7c 00 	lds	r24, 0x007C	; 0x80007c <temp_kessel>
 410:	08 95       	ret
	else
		return temp_dach;	//dummy
 412:	80 91 7d 00 	lds	r24, 0x007D	; 0x80007d <temp_dach>
}
 416:	08 95       	ret

00000418 <__vector_5>:



ISR(TIMER2_OVF_vect)
{
 418:	1f 92       	push	r1
 41a:	0f 92       	push	r0
 41c:	0f b6       	in	r0, 0x3f	; 63
 41e:	0f 92       	push	r0
 420:	11 24       	eor	r1, r1
 422:	8f 93       	push	r24
 424:	9f 93       	push	r25
	cli();
 426:	f8 94       	cli
	
	if(loop_cnt < 62) //if 5s are not passed
 428:	80 91 7b 00 	lds	r24, 0x007B	; 0x80007b <loop_cnt>
 42c:	8e 33       	cpi	r24, 0x3E	; 62
 42e:	30 f4       	brcc	.+12     	; 0x43c <__vector_5+0x24>
	{
		loop_cnt++;
 430:	80 91 7b 00 	lds	r24, 0x007B	; 0x80007b <loop_cnt>
 434:	8f 5f       	subi	r24, 0xFF	; 255
 436:	80 93 7b 00 	sts	0x007B, r24	; 0x80007b <loop_cnt>
 43a:	06 c0       	rjmp	.+12     	; 0x448 <__vector_5+0x30>
	}
	
	else	//if it is time to work...
	{
		PORTD ^= (1<<PD5);
 43c:	92 b3       	in	r25, 0x12	; 18
 43e:	80 e2       	ldi	r24, 0x20	; 32
 440:	89 27       	eor	r24, r25
 442:	82 bb       	out	0x12, r24	; 18
		loop_cnt = 0;
 444:	10 92 7b 00 	sts	0x007B, r1	; 0x80007b <loop_cnt>
	}
	
	
	TIFR &= ~(1<<TOV2);			//clear flag
 448:	88 b7       	in	r24, 0x38	; 56
 44a:	8f 7b       	andi	r24, 0xBF	; 191
 44c:	88 bf       	out	0x38, r24	; 56
		
	sei();
 44e:	78 94       	sei
 450:	9f 91       	pop	r25
 452:	8f 91       	pop	r24
 454:	0f 90       	pop	r0
 456:	0f be       	out	0x3f, r0	; 63
 458:	0f 90       	pop	r0
 45a:	1f 90       	pop	r1
 45c:	18 95       	reti

0000045e <Timeout_init>:
#include "regulator.h"
#include "uart.h"

void Timeout_init()
{
	TCCR1A = 0x00;
 45e:	1f bc       	out	0x2f, r1	; 47
	
	TIMSK |= (1<<TOIE1);			//enable overflow-event
 460:	89 b7       	in	r24, 0x39	; 57
 462:	84 60       	ori	r24, 0x04	; 4
 464:	89 bf       	out	0x39, r24	; 57
	sei();
 466:	78 94       	sei
 468:	08 95       	ret

0000046a <start_timeout_timer>:
}
void start_timeout_timer()
{
	TCNT1 = 0;						 //reset timer counter value
 46a:	1d bc       	out	0x2d, r1	; 45
 46c:	1c bc       	out	0x2c, r1	; 44
	TCCR1B = (1<<CS12) | (1<<CS10);  //start timer at prescaler /1024
 46e:	85 e0       	ldi	r24, 0x05	; 5
 470:	8e bd       	out	0x2e, r24	; 46
 472:	08 95       	ret

00000474 <stop_timeout_timer>:
}

void stop_timeout_timer()
{
	TCCR1B = ~((1<<CS12) | (1<<CS10)); //stop timer
 474:	8a ef       	ldi	r24, 0xFA	; 250
 476:	8e bd       	out	0x2e, r24	; 46
 478:	08 95       	ret

0000047a <__vector_9>:




ISR(TIMER1_OVF_vect)
{
 47a:	1f 92       	push	r1
 47c:	0f 92       	push	r0
 47e:	0f b6       	in	r0, 0x3f	; 63
 480:	0f 92       	push	r0
 482:	11 24       	eor	r1, r1
 484:	2f 93       	push	r18
 486:	3f 93       	push	r19
 488:	4f 93       	push	r20
 48a:	5f 93       	push	r21
 48c:	6f 93       	push	r22
 48e:	7f 93       	push	r23
 490:	8f 93       	push	r24
 492:	9f 93       	push	r25
 494:	af 93       	push	r26
 496:	bf 93       	push	r27
 498:	cf 93       	push	r28
 49a:	ef 93       	push	r30
 49c:	ff 93       	push	r31
	PORTD |= (1<<PD5);
 49e:	95 9a       	sbi	0x12, 5	; 18
	
	cli();
 4a0:	f8 94       	cli
	
	if((getState() == 3) && (eeprom_read_byte(0) != get_delta()))
 4a2:	0e 94 dc 01 	call	0x3b8	; 0x3b8 <getState>
 4a6:	83 30       	cpi	r24, 0x03	; 3
 4a8:	99 f4       	brne	.+38     	; 0x4d0 <__vector_9+0x56>
 4aa:	80 e0       	ldi	r24, 0x00	; 0
 4ac:	90 e0       	ldi	r25, 0x00	; 0
 4ae:	0e 94 a7 02 	call	0x54e	; 0x54e <eeprom_read_byte>
 4b2:	c8 2f       	mov	r28, r24
 4b4:	0e 94 01 02 	call	0x402	; 0x402 <get_delta>
 4b8:	c8 17       	cp	r28, r24
 4ba:	51 f0       	breq	.+20     	; 0x4d0 <__vector_9+0x56>
	{
		eeprom_update_byte((uint8_t*)(0), (uint8_t)get_delta());
 4bc:	0e 94 01 02 	call	0x402	; 0x402 <get_delta>
 4c0:	68 2f       	mov	r22, r24
 4c2:	80 e0       	ldi	r24, 0x00	; 0
 4c4:	90 e0       	ldi	r25, 0x00	; 0
 4c6:	0e 94 af 02 	call	0x55e	; 0x55e <eeprom_update_byte>
		uart_send_blocking('s');
 4ca:	83 e7       	ldi	r24, 0x73	; 115
 4cc:	0e 94 8e 02 	call	0x51c	; 0x51c <uart_send_blocking>
	}
	
	setState(1);
 4d0:	81 e0       	ldi	r24, 0x01	; 1
 4d2:	0e 94 84 01 	call	0x308	; 0x308 <setState>
	
	TIFR &= ~(1<<TOV1);
 4d6:	88 b7       	in	r24, 0x38	; 56
 4d8:	8b 7f       	andi	r24, 0xFB	; 251
 4da:	88 bf       	out	0x38, r24	; 56
	sei();
 4dc:	78 94       	sei
	
	PORTD &= ~(1<<PD5);
 4de:	95 98       	cbi	0x12, 5	; 18
 4e0:	ff 91       	pop	r31
 4e2:	ef 91       	pop	r30
 4e4:	cf 91       	pop	r28
 4e6:	bf 91       	pop	r27
 4e8:	af 91       	pop	r26
 4ea:	9f 91       	pop	r25
 4ec:	8f 91       	pop	r24
 4ee:	7f 91       	pop	r23
 4f0:	6f 91       	pop	r22
 4f2:	5f 91       	pop	r21
 4f4:	4f 91       	pop	r20
 4f6:	3f 91       	pop	r19
 4f8:	2f 91       	pop	r18
 4fa:	0f 90       	pop	r0
 4fc:	0f be       	out	0x3f, r0	; 63
 4fe:	0f 90       	pop	r0
 500:	1f 90       	pop	r1
 502:	18 95       	reti

00000504 <uart_init>:
#include <avr/io.h>


void uart_init(uint32_t baud)
{
	UCSRB |= (1<<RXEN) | (1<<TXEN);  //enable receive and transmit
 504:	8a b1       	in	r24, 0x0a	; 10
 506:	88 61       	ori	r24, 0x18	; 24
 508:	8a b9       	out	0x0a, r24	; 10
	UBRRL = 51;						 //setting datarate to 9600 baud/s
 50a:	83 e3       	ldi	r24, 0x33	; 51
 50c:	89 b9       	out	0x09, r24	; 9

	UCSRB |= (1<<RXEN) | (1<<TXEN);
 50e:	8a b1       	in	r24, 0x0a	; 10
 510:	88 61       	ori	r24, 0x18	; 24
 512:	8a b9       	out	0x0a, r24	; 10

	UCSRC |= (1<<URSEL) | (1<<UCSZ1) | (1<<UCSZ0);
 514:	80 b5       	in	r24, 0x20	; 32
 516:	86 68       	ori	r24, 0x86	; 134
 518:	80 bd       	out	0x20, r24	; 32
 51a:	08 95       	ret

0000051c <uart_send_blocking>:
}


void uart_send_blocking(uint8_t data)
{
	UDR = data;
 51c:	8c b9       	out	0x0c, r24	; 12
	while( (UCSRA & (1<<TXC)) == 0 ) //wait for transfer finished
 51e:	5e 9b       	sbis	0x0b, 6	; 11
 520:	fe cf       	rjmp	.-4      	; 0x51e <uart_send_blocking+0x2>
	{
	}
	UCSRA &= ~(1<<TXC);
 522:	5e 98       	cbi	0x0b, 6	; 11
 524:	08 95       	ret

00000526 <__udivmodhi4>:
 526:	aa 1b       	sub	r26, r26
 528:	bb 1b       	sub	r27, r27
 52a:	51 e1       	ldi	r21, 0x11	; 17
 52c:	07 c0       	rjmp	.+14     	; 0x53c <__udivmodhi4_ep>

0000052e <__udivmodhi4_loop>:
 52e:	aa 1f       	adc	r26, r26
 530:	bb 1f       	adc	r27, r27
 532:	a6 17       	cp	r26, r22
 534:	b7 07       	cpc	r27, r23
 536:	10 f0       	brcs	.+4      	; 0x53c <__udivmodhi4_ep>
 538:	a6 1b       	sub	r26, r22
 53a:	b7 0b       	sbc	r27, r23

0000053c <__udivmodhi4_ep>:
 53c:	88 1f       	adc	r24, r24
 53e:	99 1f       	adc	r25, r25
 540:	5a 95       	dec	r21
 542:	a9 f7       	brne	.-22     	; 0x52e <__udivmodhi4_loop>
 544:	80 95       	com	r24
 546:	90 95       	com	r25
 548:	bc 01       	movw	r22, r24
 54a:	cd 01       	movw	r24, r26
 54c:	08 95       	ret

0000054e <eeprom_read_byte>:
 54e:	e1 99       	sbic	0x1c, 1	; 28
 550:	fe cf       	rjmp	.-4      	; 0x54e <eeprom_read_byte>
 552:	9f bb       	out	0x1f, r25	; 31
 554:	8e bb       	out	0x1e, r24	; 30
 556:	e0 9a       	sbi	0x1c, 0	; 28
 558:	99 27       	eor	r25, r25
 55a:	8d b3       	in	r24, 0x1d	; 29
 55c:	08 95       	ret

0000055e <eeprom_update_byte>:
 55e:	26 2f       	mov	r18, r22

00000560 <eeprom_update_r18>:
 560:	e1 99       	sbic	0x1c, 1	; 28
 562:	fe cf       	rjmp	.-4      	; 0x560 <eeprom_update_r18>
 564:	9f bb       	out	0x1f, r25	; 31
 566:	8e bb       	out	0x1e, r24	; 30
 568:	e0 9a       	sbi	0x1c, 0	; 28
 56a:	01 97       	sbiw	r24, 0x01	; 1
 56c:	0d b2       	in	r0, 0x1d	; 29
 56e:	02 16       	cp	r0, r18
 570:	31 f0       	breq	.+12     	; 0x57e <eeprom_update_r18+0x1e>
 572:	2d bb       	out	0x1d, r18	; 29
 574:	0f b6       	in	r0, 0x3f	; 63
 576:	f8 94       	cli
 578:	e2 9a       	sbi	0x1c, 2	; 28
 57a:	e1 9a       	sbi	0x1c, 1	; 28
 57c:	0f be       	out	0x3f, r0	; 63
 57e:	08 95       	ret

00000580 <_exit>:
 580:	f8 94       	cli

00000582 <__stop_program>:
 582:	ff cf       	rjmp	.-2      	; 0x582 <__stop_program>
